# 不同文章类型的检查清单

本文档针对作者常见的五种文章类型，提供具体的检查清单和审稿重点。

## 硬核笔记

**定义**：记录技术实践中遇到的 Bug、调试过程、踩坑经验的文章。

**示例**：《DragonOS pwritev 系统调用调试记录》、《GDB 追踪 SIGSEGV 之谜》

---

### 结构检查

- [ ] **问题场景是否清晰**：
  - [ ] 描述了遇到什么问题？
  - [ ] 问题发生在什么环境下（OS、编译器、配置等）？
  - [ ] 问题的影响是什么（崩溃、错误结果、性能问题）？

- [ ] **Bug 复现步骤是否完整**：
  - [ ] 读者能否按照步骤复现 Bug？
  - [ ] 每个步骤是否清晰？
  - [ ] 是否提供了必要的代码或配置？

- [ ] **调试过程是否按时间线记录**：
  - [ ] 按照调试的先后顺序组织内容
  - [ ] 每次尝试的目标是什么？
  - [ ] 每次尝试的结果是什么？

---

### 内容检查

- [ ] **是否分析了 Bug 的根本原因**：
  - [ ] 不只是说"怎么修复的"，更说"为什么会出这个问题"
  - [ ] 分析是否深入到原理层面？
  - [ ] 是否有证据支撑（源码、文档、测试）？

- [ ] **是否总结了避免类似问题的经验**：
  - [ ] 从这个 Bug 中学到了什么？
  - [ ] 如何避免类似问题？
  - [ ] 是否提炼出了可复用的经验或原则？

- [ ] **代码片段是否有注释**：
  - [ ] 关键代码是否有注释？
  - [ ] 注释解释了"为什么"而不只是"做什么"？

---

### 避免

- ❌ **流水账式的记录**：
  ```
  "今天我试了方法A，不行。然后试了方法B，也不行。最后试了方法C，终于解决了。"
  ```
  缺少思考和分析。

- ❌ **只记录现象，不分析原因**：
  ```
  "我把这行代码改了，问题就解决了。"
  ```
  没有说明为什么这样改能解决问题。

- ❌ **缺少必要的上下文**：
  直接贴代码，但没说明代码在做什么、为什么要看这段代码。

---

## 理论推导

**定义**：对算法、定理、性质进行形式化证明或归纳的文章。

**示例**：《为什么快速排序的平均复杂度是 O(n log n)》、《B+ 树的并发控制正确性证明》

---

### 结构检查

- [ ] **问题定义是否清晰**：
  - [ ] 要证明什么命题？
  - [ ] 前提条件是什么？
  - [ ] 期望得到什么结论？

- [ ] **证明过程是否完整**：
  - [ ] 每个推导步骤是否有依据？
  - [ ] 是否有跳跃式推理？
  - [ ] 关键步骤是否有详细说明？

- [ ] **结论是否明确**：
  - [ ] 证明了什么？
  - [ ] 结论的适用范围是什么？
  - [ ] 是否指出了边界条件？

---

### 内容检查

- [ ] **每个推导步骤是否有依据**：
  - [ ] 引用了定理、引理或已知结果？
  - [ ] 逻辑推理是否严密？
  - [ ] 是否有循环论证？

- [ ] **是否使用了正确的数学符号**：
  - [ ] 符号首次出现时是否定义？
  - [ ] 符号使用是否一致？
  - [ ] 符号是否规范（如使用 ∈ 而不是 in）？

- [ ] **归纳是否严谨**：
  - [ ] 基础情况是否验证？
  - [ ] 归纳假设是否明确？
  - [ ] 归纳步骤是否完整？

---

### 避免

- ❌ **跳跃式推理**：
  ```
  "显然，我们可以得到..."
  ```
  但实际上不显然，缺少中间步骤。

- ❌ **符号使用不一致**：
  前面用 `n` 表示数组长度，后面又用 `n` 表示循环变量。

- ❌ **缺少必要的图示**：
  对于复杂的证明，没有辅助图示帮助理解。

---

## 源码解析

**定义**：分析系统、库、框架的实现细节，讲解架构和设计的文章。

**示例**：《DragonOS Time 子系统拆解》、《Redis 事件循环实现分析》

---

### 结构检查

- [ ] **是否先给出了架构概览**：
  - [ ] 是否先用类图或包图展示整体结构？
  - [ ] 核心模块和它们的职责是什么？
  - [ ] 模块之间如何交互？

- [ ] **是否模块化拆解**：
  - [ ] 每个模块单独讲解？
  - [ ] 模块的讲解顺序是否合理（从简单到复杂，从外围到核心）？
  - [ ] 模块之间的依赖关系是否清晰？

- [ ] **是否有图表辅助理解**：
  - [ ] 类图（Class Diagram）展示静态结构？
  - [ ] 时序图（Sequence Diagram）展示动态交互？
  - [ ] 包图（Package Diagram）展示模块依赖？

---

### 内容检查

- [ ] **代码示例是否典型**：
  - [ ] 选择的代码片段是否典型？
  - [ ] 是否去除了不重要的细节（如错误处理）？
  - [ ] 代码是否足够完整，能独立理解？

- [ ] **是否解释了设计思想**：
  - [ ] 为什么这样设计？
  - [ ] 有哪些设计权衡？
  - [ ] 采用了什么设计模式？

- [ ] **是否分析了关键数据结构**：
  - [ ] 核心数据结构是什么？
  - [ ] 为什么要这样设计数据结构？
  - [ ] 数据结构如何影响算法和行为？

---

### 避免

- ❌ **只讲代码实现，不讲设计思想**：
  逐行翻译代码，但没说明为什么这样设计。

- ❌ **代码片段过长且缺少注释**：
  直接贴了几百行代码，读者很难找到重点。

- ❌ **缺少架构视角**：
  直接跳到细节，没有先给出整体架构。

---

## 工具折腾

**定义**：记录配置工具、环境搭建、插件安装等实践的文章。

**示例**：《Neovim 配置心得》、《WSL2 调优指南》、《配置高性能 C++ 开发环境》

---

### 结构检查

- [ ] **问题场景是否真实**：
  - [ ] 为什么要配置这个工具？
  - [ ] 遇到了什么问题（性能、功能、易用性）？
  - [ ] 期望达到什么效果？

- [ ] **解决方案是否可复现**：
  - [ ] 配置步骤是否完整？
  - [ ] 是否提供了配置文件或脚本？
  - [ ] 读者能否按照步骤复现？

- [ ] **是否说明了踩坑过程**：
  - [ ] 配置过程中遇到了哪些问题？
  - [ ] 如何解决的？
  - [ ] 有哪些常见的错误？

---

### 内容检查

- [ ] **配置步骤是否完整**：
  - [ ] 每个步骤是否清晰？
  - [ ] 是否说明了配置项的含义？
  - [ ] 是否提供了验证方法？

- [ ] **是否解释了配置项的含义**：
  - [ ] 不只是说"这样配置"，更说"为什么这样配置"
  - [ ] 不同配置选项的影响是什么？
  - [ ] 如何根据需求调整配置？

- [ ] **是否提供了验证方法**：
  - [ ] 如何验证配置是否成功？
  - [ ] 是否有预期的输出或截图？

---

### 避免

- ❌ **单纯的配置罗列**：
  ```
  "在 .vimrc 中添加以下配置..."
  ```
  但没说明这些配置是做什么的、为什么要这样配置。

- ❌ **缺少踩坑经验**：
  配置过程过于顺利，缺少真实的踩坑记录。

- ❌ **缺少原理说明**：
  只说"怎么配"，没说"为什么这样配置有效"。

---

## 技术思考

**定义**：对技术选型、架构设计、编程范式等问题的思考和总结。

**示例**：《从图书馆到搜索引擎：树分类与标签分类的两种思维》、《为什么我选择 Rust 而非 C++》

---

### 结构检查

- [ ] **观点是否明确**：
  - [ ] 核心观点是什么？
  - [ ] 是否在开头就明确表达？
  - [ ] 读者能否一眼看出文章要讲什么？

- [ ] **论证是否有说服力**：
  - [ ] 是否有具体例子支撑观点？
  - [ ] 是否有对比分析？
  - [ ] 是否考虑了反面观点？

- [ ] **是否考虑了适用边界**：
  - [ ] 观点在什么情况下成立？
  - [ ] 什么情况下不适用？
  - [ ] 是否避免了绝对化的表述？

---

### 内容检查

- [ ] **是否有具体例子支撑**：
  - [ ] 不泛泛而谈，有具体的技术案例
  - [ ] 例子是否恰当、有代表性？
  - [ ] 例子是否能支撑观点？

- [ ] **类比是否恰当**：
  - [ ] 是否用了生活化类比帮助理解？
  - [ ] 类比是否准确？
  - [ ] 类比是否会误导读者？

- [ ] **是否指出了适用边界**：
  - [ ] 观点不是放之四海而皆准的
  - [ ] 明确指出适用场景和不适用场景
  - [ ] 避免绝对化的表述（如"永远"、"从不"）

---

### 避免

- ❌ **泛泛而谈，缺少具体例子**：
  ```
  "我们应该追求代码质量。"
  ```
  但没有说什么是代码质量、如何提升代码质量。

- ❌ **观点极端，缺乏平衡**：
  ```
  "C++ 已经过时了，永远不要用 C++。"
  ```
  没有考虑 C++ 仍有适用场景。

- ❌ **缺少论证过程**：
  直接给出结论，但没有解释为什么这样认为。

---

## 文章类型识别

在审稿时，如何判断文章属于哪种类型？

### 快速识别

| 文章特征 | 主要类型 |
|---------|---------|
| 记录 Bug、调试过程 | 硬核笔记 |
| 有证明、推导、定理 | 理论推导 |
| 有类图、时序图、源码分析 | 源码解析 |
| 讲配置、环境搭建 | 工具折腾 |
| 讨论"为什么"、"怎么选" | 技术思考 |

### 混合类型

很多文章是多种类型的混合，例如：
- **源码解析 + 硬核笔记**：分析源码时遇到了 Bug，记录调试过程
- **工具折腾 + 技术思考**：配置工具的过程中，对工具的设计产生思考

对于混合类型，审稿时应兼顾所有相关类型的检查要点。

---

## 审稿检查清单（总结）

审稿时，根据文章类型选择对应的检查清单：

1. **硬核笔记**：重点检查问题场景、Bug 复现步骤、根本原因分析、经验总结
2. **理论推导**：重点检查问题定义、证明过程、符号使用、结论明确性
3. **源码解析**：重点检查架构概览、模块化拆解、设计思想、代码示例
4. **工具折腾**：重点检查问题场景、配置步骤、踩坑过程、原理说明
5. **技术思考**：重点检查观点明确性、论证说服力、具体例子、适用边界
