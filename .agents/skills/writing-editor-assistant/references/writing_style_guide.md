# 写作风格指南

本文档基于作者（MiWu）的写作风格偏好，为 writing-editor-assistant 提供风格指导。

## 作者风格偏好（来自 AGENTS.md）

根据 `.agents/AGENTS.md`，作者的写作风格偏好：

- **严谨客观**：技术细节不含糊，不懂的地方承认不懂
- **逻辑清晰**：偏好结构化的表达（背景-问题-尝试-解决-原理）
- **人文感性**：偶尔可以穿插对个人喜好（如动画《四月是你的谎言》）的隐喻或感悟，让技术文章不那么冰冷

---

## 1. 严谨客观

### 承认不确定性

当作者对某个技术点不确定时，应该明确表达，而不是装作懂了。

**示例**：
```markdown
❌ 不好的写法（假装懂了）：
"Rust 的编译器使用了图归约算法进行优化。"

✅ 好的写法（承认不确定性）：
"Rust 的编译器使用了某种图归约算法进行优化，具体细节我还不确定。推测可能是基于 MIR（Mid-level IR）构建依赖图，然后进行迭代优化。"
```

**为什么**：
- 承认不确定性体现学术诚信
- 让读者知道这是推测，不是事实
- 为后续更正留出空间

---

### 区分事实和观点

明确区分"是什么"（事实）和"我认为"（观点）。

**示例**：
```markdown
❌ 不好的写法（混淆事实和观点）：
"这个设计很糟糕，会导致性能问题。"

✅ 好的写法（区分事实和观点）：
"根据源码（事实），这个设计使用了双重循环遍历所有元素（事实）。我认为，在大数据量下这可能导致性能问题（观点）。具体的影响需要通过性能测试来验证（事实）。"
```

**为什么**：
- 事实可以被验证，观点是主观判断
- 区分二者让读者知道哪些是确定的，哪些是作者的主观看法
- 读者可以不同意观点，但不能否认事实

---

### 避免绝对化

避免使用"永远"、"从不"、"总是"等绝对化表述。

**示例**：
```markdown
❌ 不好的写法（绝对化）：
"永远不要使用 C 语言中的 `goto`。"
"C++ 总是比 Rust 慢。"

✅ 好的写写法（留有余地）：
"在大多数情况下，应该避免使用 C 语言中的 `goto`，因为会使控制流难以理解。但在某些场景下（如跳出多重循环），`goto` 可能是最清晰的方式。"
"通常，Rust 的零成本抽象可以生成与 C++ 相当的机器码。但在某些特定场景下（如极端的手工优化），C++ 可能仍有优势。"
```

**为什么**：
- 技术领域很少有绝对的"总是"或"从不"
- 绝对化表述容易被反驳
- 留有余地更严谨

---

## 2. 逻辑清晰

### 使用显式结构

作者偏好结构化的表达，常用的结构有：

**结构 A：背景-问题-尝试-解决-原理**
```markdown
## 背景
我在开发 DragonOS 时遇到了一个需求...

## 问题
需要实现 `pwritev` 系统调用，但在测试 gvisor 兼容性时遇到了 SIGSEGV 错误...

## 尝试
我首先尝试了...但失败了。
然后尝试了...还是失败。

## 解决
最终通过...解决了问题。关键在于...

## 原理
为什么这样能解决问题？从原理上看...
```

**结构 B：是什么-为什么-怎么做**
```markdown
## 什么是 RAII
RAII（Resource Acquisition Is Initialization）是...

## 为什么要用 RAII
传统的资源管理存在以下问题...

## 怎么使用 RAII
在 C++ 中，可以通过智能指针来实现 RAII...
```

**为什么使用显式结构**：
- 读者一眼就能看出文章的组织方式
- 每个部分聚焦一个主题，不会混乱
- 符合认知规律，更容易理解

---

### 使用过渡句

章节之间、段落之间应该有过渡，而不是生硬地切换。

**示例**：
```markdown
❌ 不好的写法（缺少过渡）：
"RAII 可以自动管理资源。
智能指针是 RAII 的典型应用。"

✅ 好的写法（有过渡）：
"RAII 可以自动管理资源。
了解了 RAII 的原理后，让我们看看如何在实践中应用它。智能指针是 C++ 标准库提供的 RAII 封装..."
```

**常用的过渡句**：
- "了解了基本概念后，让我们看看如何应用..."
- "有了这个基础，现在可以深入..."
- "但这带来了一个问题：..."
- "为了解决这个问题，我们需要..."

---

### 段落主题句

每个段落开头用一句话概括段落主题。

**示例**：
```markdown
❌ 不好的写法（缺少主题句）：
"Rust 的所有权机制确保内存安全。编译器会在编译时检查所有权的规则，如果有违反，程序无法编译。每个值都有一个所有者，当所有者离开作用域时，值会被自动释放。"

✅ 好的写法（有主题句）：
"Rust 的所有权机制通过编译时检查确保内存安全。编译器会在编译时检查所有权的规则，如果有违反，程序无法编译。具体来说，每个值都有一个所有者，当所有者离开作用域时，值会被自动释放。"
```

**为什么**：
- 读者扫描第一句就知道这段讲什么
- 如果不感兴趣，可以跳过
- 更容易快速理解文章结构

---

## 3. 人文感性（谨慎使用）

技术文章的核心是技术，但适当的人文感性可以让文章更易读、更有温度。

### 适当的类比

将技术概念与生活场景类比，帮助读者建立直觉。

**示例**：
```markdown
**树分类**就像整理书架：
- 每本书只能放在一个位置
- 你需要记住分类层级才能找到书

**标签分类**就像给文章贴多个便利贴：
- 一篇文章可以有多个标签
- 你可以按任意标签组合查找
```

**为什么有效**：
- 从熟悉的生活场景入手，降低理解门槛
- 建立直观印象，再深入原理
- 让技术不那么冰冷

**注意**：
- 类比必须准确，不能误导
- 类比之后还是要讲原理
- 不要过度使用，一篇一两处即可

---

### 个人感悟

在总结或引入时，可以表达个人感受。

**示例**：
```markdown
## 总结
学习 Rust 的所有权机制让我重新思考了资源管理的问题。以前我总觉得 C++ 的智能指针已经够用，但看到 Rust 如何通过编译器强制保证安全，我意识到还有更优雅的方式。

当然，Rust 的学习曲线确实陡峭。在初学时，我也经常和借用检查器"搏斗"。但一旦掌握了所有权和借用的思维，写出的代码既安全又高效，这种成就感是值得的。

就像观看动画《四月是你的谎言》，主角在音乐中成长，我也在学习 Rust 的过程中不断突破自己的认知边界。
```

**何时使用个人感悟**：
- 文章的开头或结尾
- 总结性的段落
- 表达学习过程中的困惑和顿悟

**避免过度**：
- 不要让个人情感盖过技术内容
- 技术文章的核心仍然是技术
- 人文感性是点缀，不是主角

---

## 风格一致性

### 术语一致性

同一概念在整个文章中使用相同的术语。

**示例**：
```markdown
❌ 不好的写法（术语不一致）：
"Rust 的所有权（Ownership）机制确保内存安全。每个值都有一个 owner（所有者），当 owner 离开 scope 时，值会被 drop。"

✅ 好的写法（术语一致）：
"Rust 的所有权（Ownership）机制确保内存安全。每个值都有一个所有者（owner），当所有者离开作用域（scope）时，值会被释放（drop）。"
```

**为什么**：
- 避免读者困惑
- 建立清晰的概念映射
- 让文章更专业

---

### 代词一致性

选择一种指代方式并保持一致。

**示例**：
```markdown
❌ 不好的写法（代词不一致）：
"当我们编写代码时，你应该注意...如果一个人不注意..."

✅ 好的写法（代词一致）：
"当我们编写代码时，我们应该注意..."

或者：

"当你编写代码时，你应该注意..."
```

---

### 时态一致性

技术描述通常用一般现在时。

**示例**：
```markdown
❌ 不好的写法（时态混乱）：
"当你调用这个函数时，它返回了一个值。然后你可以使用这个值..."

✅ 好的写法（时态一致）：
"当你调用这个函数时，它会返回一个值。然后你可以使用这个值..."
```

---

## 常见问题

### Q: 技术文章是否可以有个人风格？

**A**: 可以，但要有度。作者的风格是"严谨客观 + 逻辑清晰 + 轻度人文感性"。个人风格应该体现在：
- 对技术的独特见解
- 恰当的类比和隐喻
- 总结时的个人感悟

但不应该：
- 影响技术的准确性
- 让文章变得主观臆断
- 盖过技术内容本身

---

### Q: 如何平衡"严谨"和"易懂"？

**A**:
- **严谨**体现在：技术细节准确、不装懂、区分事实和观点
- **易懂**体现在：结构清晰、有类比、有过渡

两者不矛盾。严谨的文章也可以很易懂，只要结构清晰、表达准确。

---

### Q: 是否应该避免使用"我"？

**A**:
- 技术描述中，尽量用客观表述（"这个函数..."、"这个设计..."）
- 表达个人观点时，明确用"我认为"（区分事实和观点）
- 学习感悟、踩坑经历中，可以用"我"（增加真实感）

核心原则：不要为了"客观"而避免使用"我"，该用的时候就要用。
